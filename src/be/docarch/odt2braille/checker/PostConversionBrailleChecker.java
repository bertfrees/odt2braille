/**
 *  odt2braille - Braille authoring in OpenOffice.org.
 *
 *  Copyright (c) 2010 by DocArch <http://www.docarch.be>.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package be.docarch.odt2braille.checker;

import java.io.File;
import java.util.Map;
import java.util.HashMap;
import java.util.Collection;
import java.util.List;
import java.util.Locale;
import java.util.ResourceBundle;
import java.util.logging.Logger;

import java.net.MalformedURLException;
import java.io.IOException;

import be.docarch.odt2braille.Constants;
import be.docarch.odt2braille.NamespaceContext;
import be.docarch.odt2braille.Settings;
import be.docarch.odt2braille.Volume;
import be.docarch.odt2braille.XPathUtils;
import be.docarch.accessibility.ExternalChecker;
import be.docarch.accessibility.Check;
import be.docarch.accessibility.Report;

/**
 * With this class a document can be checked for possible accessibility issues.
 *
 * You can
 * <ul>
 * <li>check the braille {@link Settings},</li>
 * <li>check the flat .odt file generated by OpenOffice.org,</li>
 * <li>check the intermediate daisy-like files generated by {@link Odt2Daisy}, and</li>
 * <li>check the volume lengths of the resulting braille document.</li>
 * </ul>
 *
 * The <code>PostConversionBrailleChecker</code> entity collects all of this information and uses it to generating warnings.
 *
 * @author Bert Frees
 */
public class PostConversionBrailleChecker implements ExternalChecker {

    private final static Logger logger = Logger.getLogger(Constants.LOGGER_NAME);
    private final static String L10N = Constants.L10N_PATH;

    private Map<BrailleCheck.ID,Check> checks;

    private Settings settings = null;
    private static NamespaceContext namespace = new NamespaceContext();

    private final static int MAX_VOLUME_LENGTH = 100;
    private final static int MIN_VOLUME_LENGTH = 70;
    private final static int MAX_VOLUME_DIFFERENCE = 20;
    
    private boolean volumesTooLong = false;
    private boolean volumesTooShort = false;
    private boolean volumesDifferTooMuch = false;
    private boolean preliminaryVolumeRequired = false;
    private boolean preliminaryVolumeTooShort = false;
    private boolean volumeDoesntBeginWithHeading = false;
    private boolean omissionsInsideVolume = false;
    private boolean omissionsOutsideVolume = false;
    private boolean transpositions = false;
    private boolean pageWidthTooSmall = false;
    private boolean eightDotsNotSupported = false;

    private String L10N_warning = null;
    private String L10N_question = null;
    private String L10N_details = null;

    private String L10N_eightDotsNotSupported = null;

    /**
     * Creates a new <code>PostConversionBrailleChecker</code> instance.
     *
     * @param oooLocale         The <code>Locale</code> for the user interface.
     * @param settings          The braille settings.
     */
    public PostConversionBrailleChecker(Settings settings) {

        logger.entering("Checker", "<init>");

        this.settings = settings;
        Locale oooLocale = Locale.getDefault();

        checks = new HashMap<BrailleCheck.ID,Check>();

        checks.put(BrailleCheck.ID.A_VolumesTooLong,               new BrailleCheck(BrailleCheck.ID.A_VolumesTooLong));
        checks.put(BrailleCheck.ID.A_VolumesTooShort,              new BrailleCheck(BrailleCheck.ID.A_VolumesTooShort));
        checks.put(BrailleCheck.ID.A_VolumesDifferTooMuch,         new BrailleCheck(BrailleCheck.ID.A_VolumesDifferTooMuch));
        checks.put(BrailleCheck.ID.A_PreliminaryVolumeRequired,    new BrailleCheck(BrailleCheck.ID.A_PreliminaryVolumeRequired));
        checks.put(BrailleCheck.ID.A_PreliminaryVolumeTooShort,    new BrailleCheck(BrailleCheck.ID.A_PreliminaryVolumeTooShort));
        checks.put(BrailleCheck.ID.A_VolumeDoesntBeginWithHeading, new BrailleCheck(BrailleCheck.ID.A_VolumeDoesntBeginWithHeading));
        checks.put(BrailleCheck.ID.A_OmissionsInsideVolume,        new BrailleCheck(BrailleCheck.ID.A_OmissionsInsideVolume));
        checks.put(BrailleCheck.ID.A_OmissionsOutsideVolume,       new BrailleCheck(BrailleCheck.ID.A_OmissionsOutsideVolume));
        checks.put(BrailleCheck.ID.A_Transpositions,               new BrailleCheck(BrailleCheck.ID.A_Transpositions));
        checks.put(BrailleCheck.ID.A_PageWidthTooSmall,            new BrailleCheck(BrailleCheck.ID.A_PageWidthTooSmall));

        L10N_warning = ResourceBundle.getBundle(L10N, oooLocale).getString("checkerWarning");
        L10N_question = ResourceBundle.getBundle(L10N, oooLocale).getString("checkerQuestion");
        L10N_details = ResourceBundle.getBundle(L10N, oooLocale).getString("checkerDetails");

        L10N_eightDotsNotSupported = (settings.getExportOrEmboss()?
                                            "The " + settings.getBrailleFileType().name() + " file format ":
                                            "The selected embosser ")
                                     + "doesn't support 8-dot Braille. Dots 7 and 8 will be ignored.";        
    }

    /**
     * Check an intermediate daisy-like file for possible accessibility issues.
     *
     * @param daisyFile   The daisy-like file.
     */
    public void checkDaisyFile(File daisyFile) 
                        throws MalformedURLException,
                               IOException {

        logger.entering("Checker", "checkDaisyFile");

        if (XPathUtils.evaluateBoolean(daisyFile.toURL().openStream(),
                "/dtb:dtbook//dtb:div[@class='omission' and not(ancestor::dtb:div[@class='notInVolume'])]", namespace)) {
            omissionsInsideVolume = true;
        }
        if (XPathUtils.evaluateBoolean(daisyFile.toURL().openStream(),
                "/dtb:dtbook//dtb:div[@class='notInVolume']//dtb:div[@class='omission']", namespace)) {
            omissionsOutsideVolume = true;
        }
        if (XPathUtils.evaluateBoolean(daisyFile.toURL().openStream(),
                "/dtb:dtbook//dtb:div[@class='transposition']", namespace)) {
            transpositions = true;
        }
    }

    /**
     *
     * @param pefFile
     * @throws MalformedURLException
     * @throws IOException
     */
    public void checkPefFile(File pefFile)
                      throws MalformedURLException,
                             IOException {

        logger.entering("Checker","checkPefFile");

        if (!settings.getEightDots()) {
            if (Integer.parseInt(XPathUtils.evaluateString(pefFile.toURL().openStream(),
                    "max(distinct-values(string-to-codepoints(string(/pef:pef/pef:body))))", namespace)) > 0x283F) {
                eightDotsNotSupported = true;
            }
        }
    }

    /**
     * Check the volume lengths of the resulting braille document for possible accessibility issues.
     * The volumes should not be too long or too short, and they should not differ to much in lenght.
     *
     * @param   bodyPageCount           The number of pages in the body of each volume. The other parameters should have the same array length.
     * @param   preliminaryPageCount    The number of preliminary pages in each volume.
     * @param   volumeTypes             The type of each volume ({@link VolumeType#NORMAL}, {@link VolumeType#PRELIMINARY} or
     *                                  {@link VolumeType#SUPPLEMENTARY}).
     *
     */
    public void checkVolumes(List<Volume> volumes) {

        logger.entering("Checker", "checkVolumes");

//        int bodyRectoVersoPageCount = 0;
//        int preliminaryRectoVersoPageCount = 0;
//        int maxLength = 0;
//        int minLength = Integer.MAX_VALUE;
//        int length = 0;
//
//        Volume volume;
//        Volume.Type type;
//        int volumeNr;
//        int numberOfBodyPages;
//        int numberOfPreliminaryPages;
//
//        for (int i=0;i<volumes.size();i++) {
//
//            volume = volumes.get(i);
//            type = volume.getType();
//            volumeNr = volume.getNumber();
//            numberOfBodyPages = volume.getLastBraillePage() - volume.getFirstBraillePage() + 1;
//            numberOfPreliminaryPages = volume.getNumberOfPreliminaryPages();
//
//            bodyRectoVersoPageCount = settings.getDuplex()?(int)Math.ceil(numberOfBodyPages/2):numberOfBodyPages;
//            preliminaryRectoVersoPageCount = settings.getDuplex()?(int)Math.ceil(numberOfPreliminaryPages/2):numberOfPreliminaryPages;
//            length = preliminaryRectoVersoPageCount + bodyRectoVersoPageCount;
//
//            switch (type) {
//                case PRELIMINARY:
//                    if (length < MIN_VOLUME_LENGTH) {
//                        preliminaryVolumeTooShort = true;
//                    }
//                    break;
//                case NORMAL:
//                    if (volumeNr == 1 && numberOfPreliminaryPages > MAX_VOLUME_LENGTH) {
//                        preliminaryVolumeRequired = true;
//                    }
//                    if (length > MAX_VOLUME_LENGTH) {
//                        volumesTooLong = true;
//                    }
//                    maxLength = Math.max(maxLength, length);
//                    if (volumeNr < settings.NUMBER_OF_VOLUMES) {
//                        if (length < MIN_VOLUME_LENGTH) {
//                            volumesTooShort = true;
//                        }
//                        minLength = Math.min(minLength, length);
//                    }
//                    break;
//                case SUPPLEMENTARY:
//                default:
//            }
//        }
//
//        if (settings.NUMBER_OF_VOLUMES > 1 && maxLength > minLength + MAX_VOLUME_DIFFERENCE) {
//            volumesDifferTooMuch = true;
//        }
    }

    /**
     * Generate warning.
     *
     * @return      The warning, or an empty String if no issues were detected.
     */
    public String getWarning() {

        logger.entering("Checker", "getWarning");

        String details = "";

        if (eightDotsNotSupported) {
            details += "\n \u2022 " + L10N_eightDotsNotSupported;
        }
        if (volumesTooLong) {
            details += "\n \u2022 " + checks.get(BrailleCheck.ID.A_VolumesTooLong).getDescription();
        }
        if (volumesTooShort) {
            details += "\n \u2022 " + checks.get(BrailleCheck.ID.A_VolumesTooShort).getDescription();
        }
        if (volumesDifferTooMuch) {
            details += "\n \u2022 " + checks.get(BrailleCheck.ID.A_VolumesDifferTooMuch).getDescription();
        }
        if (preliminaryVolumeRequired) {
            details += "\n \u2022 " + checks.get(BrailleCheck.ID.A_PreliminaryVolumeRequired).getDescription();
        }
        if (preliminaryVolumeTooShort) {
            details += "\n \u2022 " + checks.get(BrailleCheck.ID.A_PreliminaryVolumeTooShort).getDescription();
        }
        if (volumeDoesntBeginWithHeading) {
            details += "\n \u2022 " + checks.get(BrailleCheck.ID.A_VolumeDoesntBeginWithHeading).getDescription();
        }
        if (omissionsInsideVolume) {
            details += "\n \u2022 " + checks.get(BrailleCheck.ID.A_OmissionsInsideVolume).getDescription();
        }
        if (omissionsOutsideVolume) {
            details += "\n \u2022 " + checks.get(BrailleCheck.ID.A_OmissionsOutsideVolume).getDescription();
        }
        if (transpositions) {
            details += "\n \u2022 " + checks.get(BrailleCheck.ID.A_Transpositions).getDescription();
        }

        if (!details.equals("")) {
            return L10N_warning + "\n\n" + L10N_details + ": \n" + details + "\n\n" + L10N_question;
        } else {
            return "";
        }
    }

    @Override
    public void setOdtFile(File file) {}

    @Override
    public String getIdentifier() {
        return "be.docarch.odt2braille.checker.PostConversionBrailleChecker";
    }

    @Override
    public Collection<Check> getChecks() {
        return checks.values();
    }

    @Override
    public Report getAccessibilityReport() {
        return null;
    }

    @Override
    public boolean check() {
        return false;
    }
}
